(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[35],{

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/hooper/dist/hooper.css":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/src??ref--6-2!./node_modules/hooper/dist/hooper.css ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".hooper-slide {\\n  flex-shrink: 0;\\n  height: 100%;\\n  margin: 0;\\n  padding: 0;\\n  list-style: none;\\n}\\n\\n.hooper-progress {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  left: 0;\\n  height: 4px;\\n  background-color: #efefef;\\n}\\n\\n.hooper-progress-inner {\\n  height: 100%;\\n  background-color: #4285f4;\\n  transition: 300ms;\\n}\\n\\n.hooper-pagination {\\n  position: absolute;\\n  bottom: 0;\\n  right: 50%;\\n  transform: translateX(50%);\\n  display: flex;\\n  padding: 5px 10px;\\n}\\n\\n.hooper-indicators {\\n  display: flex;\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n.hooper-indicator:hover,\\n.hooper-indicator.is-active {\\n  background-color: #4285f4;\\n}\\n\\n.hooper-indicator {\\n  margin: 0 2px;\\n  width: 12px;\\n  height: 4px;\\n  border-radius: 4px;\\n  border: none;\\n  padding: 0;\\n  background-color: #fff;\\n  cursor: pointer;\\n}\\n\\n.hooper-pagination.is-vertical {\\n  bottom: auto;\\n  right: 0;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n\\n.hooper-pagination.is-vertical .hooper-indicators {\\n  flex-direction: column;\\n}\\n\\n.hooper-pagination.is-vertical .hooper-indicator {\\n  width: 6px;\\n}\\n\\n.hooper-next,\\n.hooper-prev {\\n  background-color: transparent;\\n  border: none;\\n  padding: 1em;\\n  position: absolute;\\n  top: 50%;\\n  transform: translateY(-50%);\\n  cursor: pointer;\\n}\\n\\n.hooper-next.is-disabled,\\n.hooper-prev.is-disabled {\\n  opacity: 0.3;\\n  cursor: not-allowed;\\n}\\n\\n.hooper-next {\\n  right: 0;\\n}\\n\\n.hooper-prev {\\n  left: 0;\\n}\\n\\n.hooper-navigation.is-vertical .hooper-next {\\n  top: auto;\\n  bottom: 0;\\n  transform: initial;\\n}\\n\\n.hooper-navigation.is-vertical .hooper-prev {\\n  top: 0;\\n  bottom: auto;\\n  right: 0;\\n  left: auto;\\n  transform: initial;\\n}\\n\\n.hooper-navigation.is-rtl .hooper-prev {\\n  left: auto;\\n  right: 0;\\n}\\n\\n.hooper-navigation.is-rtl .hooper-next {\\n  right: auto;\\n  left: 0;\\n}\\n\\n.hooper {\\n  position: relative;\\n  box-sizing: border-box;\\n  width: 100%;\\n  height: 200px;\\n}\\n\\n.hooper * {\\n  box-sizing: border-box;\\n}\\n\\n.hooper-list {\\n  overflow: hidden;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.hooper-track {\\n  display: flex;\\n  box-sizing: border-box;\\n  width: 100%;\\n  height: 100%;\\n  padding: 0;\\n  margin: 0;\\n}\\n\\n.hooper.is-vertical .hooper-track {\\n  flex-direction: column;\\n  height: 200px;\\n}\\n\\n.hooper.is-rtl {\\n  direction: rtl;\\n}\\n\\n.hooper-sr-only {\\n  position: absolute;\\n  width: 1px;\\n  height: 1px;\\n  padding: 0;\\n  margin: -1px;\\n  overflow: hidden;\\n  clip: rect(0, 0, 0, 0);\\n  border: 0;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9vcGVyL2Rpc3QvaG9vcGVyLmNzcz8yZDljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLG1GQUFrQztBQUNyRTs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsa0JBQWtCLG1CQUFtQixpQkFBaUIsY0FBYyxlQUFlLHFCQUFxQixHQUFHLHNCQUFzQix1QkFBdUIsV0FBVyxhQUFhLFlBQVksZ0JBQWdCLDhCQUE4QixHQUFHLDRCQUE0QixpQkFBaUIsOEJBQThCLHNCQUFzQixHQUFHLHdCQUF3Qix1QkFBdUIsY0FBYyxlQUFlLCtCQUErQixrQkFBa0Isc0JBQXNCLEdBQUcsd0JBQXdCLGtCQUFrQixxQkFBcUIsY0FBYyxlQUFlLEdBQUcsMkRBQTJELDhCQUE4QixHQUFHLHVCQUF1QixrQkFBa0IsZ0JBQWdCLGdCQUFnQix1QkFBdUIsaUJBQWlCLGVBQWUsMkJBQTJCLG9CQUFvQixHQUFHLG9DQUFvQyxpQkFBaUIsYUFBYSxhQUFhLGdDQUFnQyxHQUFHLHVEQUF1RCwyQkFBMkIsR0FBRyxzREFBc0QsZUFBZSxHQUFHLGlDQUFpQyxrQ0FBa0MsaUJBQWlCLGlCQUFpQix1QkFBdUIsYUFBYSxnQ0FBZ0Msb0JBQW9CLEdBQUcseURBQXlELGlCQUFpQix3QkFBd0IsR0FBRyxrQkFBa0IsYUFBYSxHQUFHLGtCQUFrQixZQUFZLEdBQUcsaURBQWlELGNBQWMsY0FBYyx1QkFBdUIsR0FBRyxpREFBaUQsV0FBVyxpQkFBaUIsYUFBYSxlQUFlLHVCQUF1QixHQUFHLDRDQUE0QyxlQUFlLGFBQWEsR0FBRyw0Q0FBNEMsZ0JBQWdCLFlBQVksR0FBRyxhQUFhLHVCQUF1QiwyQkFBMkIsZ0JBQWdCLGtCQUFrQixHQUFHLGVBQWUsMkJBQTJCLEdBQUcsa0JBQWtCLHFCQUFxQixnQkFBZ0IsaUJBQWlCLEdBQUcsbUJBQW1CLGtCQUFrQiwyQkFBMkIsZ0JBQWdCLGlCQUFpQixlQUFlLGNBQWMsR0FBRyx1Q0FBdUMsMkJBQTJCLGtCQUFrQixHQUFHLG9CQUFvQixtQkFBbUIsR0FBRyxxQkFBcUIsdUJBQXVCLGVBQWUsZ0JBQWdCLGVBQWUsaUJBQWlCLHFCQUFxQiwyQkFBMkIsY0FBYyxHQUFHOztBQUU1K0UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9ob29wZXIvZGlzdC9ob29wZXIuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5ob29wZXItc2xpZGUge1xcbiAgZmxleC1zaHJpbms6IDA7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLmhvb3Blci1wcm9ncmVzcyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIGxlZnQ6IDA7XFxuICBoZWlnaHQ6IDRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZmVmZWY7XFxufVxcblxcbi5ob29wZXItcHJvZ3Jlc3MtaW5uZXIge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzQyODVmNDtcXG4gIHRyYW5zaXRpb246IDMwMG1zO1xcbn1cXG5cXG4uaG9vcGVyLXBhZ2luYXRpb24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCg1MCUpO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHBhZGRpbmc6IDVweCAxMHB4O1xcbn1cXG5cXG4uaG9vcGVyLWluZGljYXRvcnMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4uaG9vcGVyLWluZGljYXRvcjpob3ZlcixcXG4uaG9vcGVyLWluZGljYXRvci5pcy1hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzQyODVmNDtcXG59XFxuXFxuLmhvb3Blci1pbmRpY2F0b3Ige1xcbiAgbWFyZ2luOiAwIDJweDtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiA0cHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmhvb3Blci1wYWdpbmF0aW9uLmlzLXZlcnRpY2FsIHtcXG4gIGJvdHRvbTogYXV0bztcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcblxcbi5ob29wZXItcGFnaW5hdGlvbi5pcy12ZXJ0aWNhbCAuaG9vcGVyLWluZGljYXRvcnMge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmhvb3Blci1wYWdpbmF0aW9uLmlzLXZlcnRpY2FsIC5ob29wZXItaW5kaWNhdG9yIHtcXG4gIHdpZHRoOiA2cHg7XFxufVxcblxcbi5ob29wZXItbmV4dCxcXG4uaG9vcGVyLXByZXYge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBwYWRkaW5nOiAxZW07XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmhvb3Blci1uZXh0LmlzLWRpc2FibGVkLFxcbi5ob29wZXItcHJldi5pcy1kaXNhYmxlZCB7XFxuICBvcGFjaXR5OiAwLjM7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbn1cXG5cXG4uaG9vcGVyLW5leHQge1xcbiAgcmlnaHQ6IDA7XFxufVxcblxcbi5ob29wZXItcHJldiB7XFxuICBsZWZ0OiAwO1xcbn1cXG5cXG4uaG9vcGVyLW5hdmlnYXRpb24uaXMtdmVydGljYWwgLmhvb3Blci1uZXh0IHtcXG4gIHRvcDogYXV0bztcXG4gIGJvdHRvbTogMDtcXG4gIHRyYW5zZm9ybTogaW5pdGlhbDtcXG59XFxuXFxuLmhvb3Blci1uYXZpZ2F0aW9uLmlzLXZlcnRpY2FsIC5ob29wZXItcHJldiB7XFxuICB0b3A6IDA7XFxuICBib3R0b206IGF1dG87XFxuICByaWdodDogMDtcXG4gIGxlZnQ6IGF1dG87XFxuICB0cmFuc2Zvcm06IGluaXRpYWw7XFxufVxcblxcbi5ob29wZXItbmF2aWdhdGlvbi5pcy1ydGwgLmhvb3Blci1wcmV2IHtcXG4gIGxlZnQ6IGF1dG87XFxuICByaWdodDogMDtcXG59XFxuXFxuLmhvb3Blci1uYXZpZ2F0aW9uLmlzLXJ0bCAuaG9vcGVyLW5leHQge1xcbiAgcmlnaHQ6IGF1dG87XFxuICBsZWZ0OiAwO1xcbn1cXG5cXG4uaG9vcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMjAwcHg7XFxufVxcblxcbi5ob29wZXIgKiB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4uaG9vcGVyLWxpc3Qge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uaG9vcGVyLXRyYWNrIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4uaG9vcGVyLmlzLXZlcnRpY2FsIC5ob29wZXItdHJhY2sge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGhlaWdodDogMjAwcHg7XFxufVxcblxcbi5ob29wZXIuaXMtcnRsIHtcXG4gIGRpcmVjdGlvbjogcnRsO1xcbn1cXG5cXG4uaG9vcGVyLXNyLW9ubHkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDFweDtcXG4gIGhlaWdodDogMXB4O1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xcbiAgYm9yZGVyOiAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/hooper/dist/hooper.css\n");

/***/ }),

/***/ "./node_modules/hooper/dist/hooper.css":
/*!*********************************************!*\
  !*** ./node_modules/hooper/dist/hooper.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader??ref--6-1!../../postcss-loader/src??ref--6-2!./hooper.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/hooper/dist/hooper.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9vcGVyL2Rpc3QvaG9vcGVyLmNzcz8zYjYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxjQUFjLG1CQUFPLENBQUMsME1BQWdHOztBQUV0SCw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQXNDOztBQUUzRDs7QUFFQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ob29wZXIvZGlzdC9ob29wZXIuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LTIhLi9ob29wZXIuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LTIhLi9ob29wZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS02LTEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtMiEuL2hvb3Blci5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hooper/dist/hooper.css\n");

/***/ }),

/***/ "./node_modules/hooper/dist/hooper.esm.js":
/*!************************************************!*\
  !*** ./node_modules/hooper/dist/hooper.esm.js ***!
  \************************************************/
/*! exports provided: default, Hooper, Icon, Navigation, Pagination, Progress, Slide, addonMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hooper\", function() { return Carousel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Icon\", function() { return Icon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Navigation\", function() { return Navigation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pagination\", function() { return Pagination; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Progress\", function() { return Progress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Slide\", function() { return Slide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addonMixin\", function() { return Mixin; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n/**\n  * Hopper 0.3.4\n  * (c) 2019\n    * @license MIT\n    */\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction getInRange(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n}\nfunction now() {\n  return Date.now();\n}\nfunction Timer(callback, time) {\n  this.create = function createTimer() {\n    return window.setInterval(callback, time);\n  };\n\n  this.stop = function stopTimer() {\n    if (this.timer) {\n      window.clearInterval(this.timer);\n      this.timer = null;\n    }\n  };\n\n  this.start = function startTimer() {\n    if (!this.timer) {\n      this.timer = this.create();\n    }\n  };\n\n  this.restart = function restartTimer(newTime) {\n    time = newTime || time;\n    this.stop();\n    this.start();\n  };\n\n  this.timer = this.create();\n}\nfunction camelCaseToString(camelCase) {\n  camelCase = camelCase.replace(/([A-Z]+)/g, ' $1');\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}\nfunction normalizeSlideIndex(index, slidesCount) {\n  var realIndex;\n\n  if (index < 0) {\n    realIndex = (index + slidesCount) % slidesCount;\n  } else {\n    realIndex = index % slidesCount;\n  } // Test for NaN\n\n\n  if (realIndex !== realIndex) {\n    return 0;\n  }\n\n  return realIndex;\n}\nfunction cloneNode(h, vNode) {\n  // use the context that the original vnode was created in.\n  var children = vNode.children || vNode.componentOptions.children || vNode.text;\n  var tag = vNode.componentOptions.Ctor;\n  return h(tag, vNode.data, children);\n} // IE11 :)\n\nfunction assignPoly(target) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    nextSource = Object(nextSource);\n    var keysArray = Object.keys(Object(nextSource));\n\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n\n  return to;\n}\n\nvar assign = Object.assign || assignPoly;\n\nfunction signPoly(value) {\n  if (value < 0) {\n    return -1;\n  }\n\n  return value > 0 ? 1 : 0;\n}\n\nvar sign = Math.sign || signPoly;\nfunction normalizeChildren(context) {\n  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (context.$scopedSlots.default) {\n    return context.$scopedSlots.default(slotProps) || [];\n  }\n\n  return context.$slots.default || [];\n}\n\nvar EMITTER = new vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nvar Carousel = {\n  name: 'Hooper',\n  provide: function provide() {\n    return {\n      $hooper: this\n    };\n  },\n  props: {\n    // count of items to showed per view\n    itemsToShow: {\n      default: 1,\n      type: Number\n    },\n    // count of items to slide when use navigation buttons\n    itemsToSlide: {\n      default: 1,\n      type: Number\n    },\n    // index number of initial slide\n    initialSlide: {\n      default: 0,\n      type: Number\n    },\n    // control infinite scrolling mode\n    infiniteScroll: {\n      default: false,\n      type: Boolean\n    },\n    // control center mode\n    centerMode: {\n      default: false,\n      type: Boolean\n    },\n    // vertical sliding mode\n    vertical: {\n      default: false,\n      type: Boolean\n    },\n    // enable rtl mode\n    rtl: {\n      default: null,\n      type: Boolean\n    },\n    // enable auto sliding to carousel\n    autoPlay: {\n      default: false,\n      type: Boolean\n    },\n    // speed of auto play to trigger slide\n    playSpeed: {\n      default: 2000,\n      type: Number\n    },\n    // toggle mouse dragging\n    mouseDrag: {\n      default: true,\n      type: Boolean\n    },\n    // toggle touch dragging\n    touchDrag: {\n      default: true,\n      type: Boolean\n    },\n    // toggle mouse wheel sliding\n    wheelControl: {\n      default: true,\n      type: Boolean\n    },\n    // toggle keyboard control\n    keysControl: {\n      default: true,\n      type: Boolean\n    },\n    // enable any move to commit a slide\n    shortDrag: {\n      default: true,\n      type: Boolean\n    },\n    // sliding transition time in ms\n    transition: {\n      default: 300,\n      type: Number\n    },\n    // pause autoPlay on mousehover\n    hoverPause: {\n      default: true,\n      type: Boolean\n    },\n    // remove empty space around slides\n    trimWhiteSpace: {\n      default: false,\n      type: Boolean\n    },\n    // an object to pass all settings\n    settings: {\n      default: function _default() {\n        return {};\n      },\n      type: Object\n    },\n    group: {\n      type: String,\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      isDragging: false,\n      isSliding: false,\n      isTouch: false,\n      isHover: false,\n      isFocus: false,\n      initialized: false,\n      slideWidth: 0,\n      slideHeight: 0,\n      slidesCount: 0,\n      trimStart: 0,\n      trimEnd: 1,\n      currentSlide: null,\n      timer: null,\n      defaults: {},\n      breakpoints: {},\n      delta: {\n        x: 0,\n        y: 0\n      },\n      config: {}\n    };\n  },\n  computed: {\n    slideBounds: function slideBounds() {\n      var config = this.config,\n          currentSlide = this.currentSlide; // Because the \"isActive\" depends on the slides shown, not the number of slidable ones.\n      // but upper and lower bounds for Next,Prev depend on whatever is smaller.\n\n      var siblings = config.itemsToShow;\n      var lower = config.centerMode ? Math.ceil(currentSlide - siblings / 2) : currentSlide;\n      var upper = config.centerMode ? Math.floor(currentSlide + siblings / 2) : Math.floor(currentSlide + siblings - 1);\n      return {\n        lower: lower,\n        upper: upper\n      };\n    },\n    trackTransform: function trackTransform() {\n      var _this$config = this.config,\n          infiniteScroll = _this$config.infiniteScroll,\n          vertical = _this$config.vertical,\n          rtl = _this$config.rtl,\n          centerMode = _this$config.centerMode;\n      var direction = rtl ? -1 : 1;\n      var slideLength = vertical ? this.slideHeight : this.slideWidth;\n      var containerLength = vertical ? this.containerHeight : this.containerWidth;\n      var dragDelta = vertical ? this.delta.y : this.delta.x;\n      var clonesSpace = infiniteScroll ? slideLength * this.slidesCount : 0;\n      var centeringSpace = centerMode ? (containerLength - slideLength) / 2 : 0; // calculate track translate\n\n      var translate = dragDelta + direction * (centeringSpace - clonesSpace - this.currentSlide * slideLength);\n\n      if (vertical) {\n        return \"transform: translate(0, \".concat(translate, \"px);\");\n      }\n\n      return \"transform: translate(\".concat(translate, \"px, 0);\");\n    },\n    trackTransition: function trackTransition() {\n      if (this.initialized && this.isSliding) {\n        return \"transition: \".concat(this.config.transition, \"ms\");\n      }\n\n      return '';\n    }\n  },\n  watch: {\n    group: function group(val, oldVal) {\n      if (val === oldVal) {\n        return;\n      }\n\n      EMITTER.$off(\"slideGroup:\".concat(oldVal), this._groupSlideHandler);\n      this.addGroupListeners();\n    }\n  },\n  methods: {\n    // controlling methods\n    slideTo: function slideTo(slideIndex) {\n      var _this = this;\n\n      var isSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (this.isSliding || slideIndex === this.currentSlide) {\n        return;\n      }\n\n      this.$emit('beforeSlide', {\n        currentSlide: this.currentSlide,\n        slideTo: index\n      });\n      var _this$config2 = this.config,\n          infiniteScroll = _this$config2.infiniteScroll,\n          transition = _this$config2.transition;\n      var previousSlide = this.currentSlide;\n      var index = infiniteScroll ? slideIndex : getInRange(slideIndex, this.trimStart, this.slidesCount - this.trimEnd); // Notify others if in a group and is the slide event initiator.\n\n      if (this.group && isSource) {\n        EMITTER.$emit(\"slideGroup:\".concat(this.group), slideIndex);\n      }\n\n      this.currentSlide = index;\n      this.isSliding = true;\n      window.setTimeout(function () {\n        _this.isSliding = false;\n        _this.currentSlide = normalizeSlideIndex(index, _this.slidesCount);\n      }, transition);\n      this.$emit('slide', {\n        currentSlide: this.currentSlide,\n        slideFrom: previousSlide\n      });\n    },\n    slideNext: function slideNext() {\n      this.slideTo(this.currentSlide + this.config.itemsToSlide);\n    },\n    slidePrev: function slidePrev() {\n      this.slideTo(this.currentSlide - this.config.itemsToSlide);\n    },\n    initEvents: function initEvents() {\n      // get the element direction if not explicitly set\n      if (this.defaults.rtl === null) {\n        this.defaults.rtl = getComputedStyle(this.$el).direction === 'rtl';\n      }\n\n      if (this.config.autoPlay) {\n        this.initAutoPlay();\n      }\n\n      if (this.config.mouseDrag) {\n        this.$refs.list.addEventListener('mousedown', this.onDragStart);\n      }\n\n      if (this.config.touchDrag) {\n        this.$refs.list.addEventListener('touchstart', this.onDragStart, {\n          passive: true\n        });\n      }\n\n      if (this.config.keysControl) {\n        this.$el.addEventListener('keydown', this.onKeypress);\n      }\n\n      if (this.config.wheelControl) {\n        this.lastScrollTime = now();\n        this.$el.addEventListener('wheel', this.onWheel, {\n          passive: false\n        });\n      }\n\n      window.addEventListener('resize', this.update);\n    },\n    initAutoPlay: function initAutoPlay() {\n      var _this2 = this;\n\n      this.timer = new Timer(function () {\n        if (_this2.isSliding || _this2.isDragging || _this2.isHover && _this2.config.hoverPause || _this2.isFocus) {\n          return;\n        }\n\n        if (_this2.currentSlide === _this2.slidesCount - 1 && !_this2.config.infiniteScroll) {\n          _this2.slideTo(0);\n\n          return;\n        }\n\n        _this2.slideNext();\n      }, this.config.playSpeed);\n    },\n    initDefaults: function initDefaults() {\n      this.breakpoints = this.settings.breakpoints;\n      this.defaults = assign({}, this.$props, this.settings);\n      this.config = assign({}, this.defaults);\n    },\n    // updating methods\n    update: function update() {\n      if (this.breakpoints) {\n        this.updateConfig();\n      }\n\n      this.updateWidth();\n      this.updateTrim();\n      this.$emit('updated', {\n        containerWidth: this.containerWidth,\n        containerHeight: this.containerHeight,\n        slideWidth: this.slideWidth,\n        slideHeight: this.slideHeight,\n        settings: this.config\n      });\n    },\n    updateTrim: function updateTrim() {\n      var _this$config3 = this.config,\n          trimWhiteSpace = _this$config3.trimWhiteSpace,\n          itemsToShow = _this$config3.itemsToShow,\n          centerMode = _this$config3.centerMode,\n          infiniteScroll = _this$config3.infiniteScroll;\n\n      if (!trimWhiteSpace || infiniteScroll) {\n        this.trimStart = 0;\n        this.trimEnd = 1;\n        return;\n      }\n\n      this.trimStart = centerMode ? Math.floor((itemsToShow - 1) / 2) : 0;\n      this.trimEnd = centerMode ? Math.ceil(itemsToShow / 2) : itemsToShow;\n    },\n    updateWidth: function updateWidth() {\n      var rect = this.$el.getBoundingClientRect();\n      this.containerWidth = rect.width;\n      this.containerHeight = rect.height;\n\n      if (this.config.vertical) {\n        this.slideHeight = this.containerHeight / this.config.itemsToShow;\n        return;\n      }\n\n      this.slideWidth = this.containerWidth / this.config.itemsToShow;\n    },\n    updateConfig: function updateConfig() {\n      var _this3 = this;\n\n      var breakpoints = Object.keys(this.breakpoints).sort(function (a, b) {\n        return b - a;\n      });\n      var matched;\n      breakpoints.some(function (breakpoint) {\n        matched = window.matchMedia(\"(min-width: \".concat(breakpoint, \"px)\")).matches;\n\n        if (matched) {\n          _this3.config = assign({}, _this3.config, _this3.defaults, _this3.breakpoints[breakpoint]);\n          return true;\n        }\n      });\n\n      if (!matched) {\n        this.config = assign(this.config, this.defaults);\n      }\n    },\n    restartTimer: function restartTimer() {\n      if (this.timer) {\n        this.timer.restart();\n      }\n    },\n    restart: function restart() {\n      var _this4 = this;\n\n      this.$nextTick(function () {\n        _this4.update();\n      });\n    },\n    // events handlers\n    onDragStart: function onDragStart(event) {\n      this.isTouch = event.type === 'touchstart';\n\n      if (!this.isTouch && event.button !== 0) {\n        return;\n      }\n\n      this.startPosition = {\n        x: 0,\n        y: 0\n      };\n      this.endPosition = {\n        x: 0,\n        y: 0\n      };\n      this.isDragging = true;\n      this.startPosition.x = this.isTouch ? event.touches[0].clientX : event.clientX;\n      this.startPosition.y = this.isTouch ? event.touches[0].clientY : event.clientY;\n      document.addEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag);\n      document.addEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd);\n    },\n    isInvalidDirection: function isInvalidDirection(deltaX, deltaY) {\n      if (!this.config.vertical) {\n        return Math.abs(deltaX) <= Math.abs(deltaY);\n      }\n\n      if (this.config.vertical) {\n        return Math.abs(deltaY) <= Math.abs(deltaX);\n      }\n\n      return false;\n    },\n    onDrag: function onDrag(event) {\n      if (this.isSliding) {\n        return;\n      }\n\n      this.endPosition.x = this.isTouch ? event.touches[0].clientX : event.clientX;\n      this.endPosition.y = this.isTouch ? event.touches[0].clientY : event.clientY;\n      var deltaX = this.endPosition.x - this.startPosition.x;\n      var deltaY = this.endPosition.y - this.startPosition.y; // Maybe scrolling.\n\n      if (this.isInvalidDirection(deltaX, deltaY)) {\n        return;\n      }\n\n      this.delta.y = deltaY;\n      this.delta.x = deltaX;\n\n      if (!this.isTouch) {\n        event.preventDefault();\n      }\n    },\n    onDragEnd: function onDragEnd() {\n      var tolerance = this.config.shortDrag ? 0.5 : 0.15;\n      this.isDragging = false;\n\n      if (this.config.vertical) {\n        var draggedSlides = Math.round(Math.abs(this.delta.y / this.slideHeight) + tolerance);\n        this.slideTo(this.currentSlide - sign(this.delta.y) * draggedSlides);\n      }\n\n      if (!this.config.vertical) {\n        var direction = (this.config.rtl ? -1 : 1) * sign(this.delta.x);\n\n        var _draggedSlides = Math.round(Math.abs(this.delta.x / this.slideWidth) + tolerance);\n\n        this.slideTo(this.currentSlide - direction * _draggedSlides);\n      }\n\n      this.delta.x = 0;\n      this.delta.y = 0;\n      document.removeEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag);\n      document.removeEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd);\n      this.restartTimer();\n    },\n    onTransitionend: function onTransitionend() {\n      this.isSliding = false;\n      this.$emit('afterSlide', {\n        currentSlide: this.currentSlide\n      });\n    },\n    onKeypress: function onKeypress(event) {\n      var key = event.key;\n\n      if (key.startsWith('Arrow')) {\n        event.preventDefault();\n      }\n\n      if (this.config.vertical) {\n        if (key === 'ArrowUp') {\n          this.slidePrev();\n        }\n\n        if (key === 'ArrowDown') {\n          this.slideNext();\n        }\n\n        return;\n      }\n\n      if (this.config.rtl) {\n        if (key === 'ArrowRight') {\n          this.slidePrev();\n        }\n\n        if (key === 'ArrowLeft') {\n          this.slideNext();\n        }\n\n        return;\n      }\n\n      if (key === 'ArrowRight') {\n        this.slideNext();\n      }\n\n      if (key === 'ArrowLeft') {\n        this.slidePrev();\n      }\n    },\n    onWheel: function onWheel(event) {\n      event.preventDefault();\n\n      if (now() - this.lastScrollTime < 200) {\n        return;\n      } // get wheel direction\n\n\n      this.lastScrollTime = now();\n      var value = event.wheelDelta || -event.deltaY;\n      var delta = sign(value);\n\n      if (delta === -1) {\n        this.slideNext();\n      }\n\n      if (delta === 1) {\n        this.slidePrev();\n      }\n    },\n    addGroupListeners: function addGroupListeners() {\n      var _this5 = this;\n\n      if (!this.group) {\n        return;\n      }\n\n      this._groupSlideHandler = function (slideIndex) {\n        // set the isSource to false to prevent infinite emitting loop.\n        _this5.slideTo(slideIndex, false);\n      };\n\n      EMITTER.$on(\"slideGroup:\".concat(this.group), this._groupSlideHandler);\n    }\n  },\n  created: function created() {\n    this.initDefaults();\n  },\n  mounted: function mounted() {\n    var _this6 = this;\n\n    this.initEvents();\n    this.addGroupListeners();\n    this.$nextTick(function () {\n      _this6.update();\n\n      _this6.slideTo(_this6.config.initialSlide || 0);\n\n      setTimeout(function () {\n        _this6.$emit('loaded');\n\n        _this6.initialized = true;\n      }, _this6.transition);\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    window.removeEventListener('resize', this.update);\n\n    if (this.group) {\n      EMITTER.$off(\"slideGroup:\".concat(this.group), this._groupSlideHandler);\n    }\n\n    if (this.timer) {\n      this.timer.stop();\n    }\n  },\n  render: function render(h) {\n    var _this7 = this;\n\n    var body = renderBody.call(this, h);\n    return h('section', {\n      class: {\n        hooper: true,\n        'is-vertical': this.config.vertical,\n        'is-rtl': this.config.rtl\n      },\n      attrs: {\n        tabindex: '0'\n      },\n      on: {\n        focusin: function focusin() {\n          return _this7.isFocus = true;\n        },\n        focusout: function focusout() {\n          return _this7.isFocus = false;\n        },\n        mouseover: function mouseover() {\n          return _this7.isHover = true;\n        },\n        mouseleave: function mouseleave() {\n          return _this7.isHover = false;\n        }\n      }\n    }, body);\n  }\n};\n/**\n * Renders additional slides for infinite slides mode.\n * By cloning Slides VNodes before and after either edges.\n */\n\nfunction renderBufferSlides(h, slides) {\n  var before = [];\n  var after = []; // reduce prop access\n\n  var slidesCount = slides.length;\n\n  for (var i = 0; i < slidesCount; i++) {\n    var slide = slides[i];\n    var clonedBefore = cloneNode(h, slide);\n    var slideIndex = i - slidesCount;\n    clonedBefore.data.key = \"before_\".concat(i);\n    clonedBefore.key = clonedBefore.data.key;\n    clonedBefore.componentOptions.propsData.index = slideIndex;\n    clonedBefore.data.props = {\n      index: slideIndex,\n      isClone: true\n    };\n    before.push(clonedBefore);\n    var clonedAfter = cloneNode(h, slide);\n    slideIndex = i + slidesCount;\n    clonedAfter.data.key = \"after_\".concat(slideIndex);\n    clonedAfter.componentOptions.propsData.index = slideIndex;\n    clonedAfter.key = clonedAfter.data.key;\n    clonedAfter.data.props = {\n      index: slideIndex,\n      isClone: true\n    };\n    after.push(clonedAfter);\n  }\n\n  return [].concat(before, _toConsumableArray(slides), after);\n}\n/**\n * Produces the VNodes for the Slides.\n * requires {this} to be bound to hooper.\n * So use with .call or .bind\n */\n\n\nfunction renderSlides(h) {\n  var children = normalizeChildren(this);\n  var childrenCount = children.length;\n  var idx = 0;\n  var slides = [];\n\n  for (var i = 0; i < childrenCount; i++) {\n    var child = children[i];\n    var ctor = child.componentOptions && child.componentOptions.Ctor;\n\n    if (!ctor || ctor.options.name !== 'HooperSlide') {\n      continue;\n    } // give slide an index behind the scenes\n\n\n    child.componentOptions.propsData.index = idx;\n    child.data.key = idx;\n    child.key = idx;\n    child.data.props = _objectSpread({}, child.data.props || {}, {\n      isClone: false,\n      index: idx++\n    });\n    slides.push(child);\n  } // update hooper's information of the slide count.\n\n\n  this.slidesCount = slides.length;\n\n  if (this.config.infiniteScroll) {\n    slides = renderBufferSlides(h, slides);\n  }\n\n  return h('ul', {\n    class: {\n      'hooper-track': true,\n      'is-dragging': this.isDragging\n    },\n    style: this.trackTransform + this.trackTransition,\n    ref: 'track',\n    on: {\n      transitionend: this.onTransitionend\n    }\n  }, slides);\n}\n/**\n * Builds the VNodes for the hooper body.\n * Which is the slides, addons if available, and a11y stuff.\n * REQUIRES {this} to be bound to the hooper instance.\n * use with .call or .bind\n */\n\n\nfunction renderBody(h) {\n  var slides = renderSlides.call(this, h);\n  var addons = this.$slots['hooper-addons'] || [];\n  var a11y = h('div', {\n    class: 'hooper-liveregion hooper-sr-only',\n    attrs: {\n      'aria-live': 'polite',\n      'aria-atomic': 'true'\n    }\n  }, \"Item \".concat(this.currentSlide + 1, \" of \").concat(this.slidesCount));\n  var children = [slides].concat(_toConsumableArray(addons), [a11y]);\n  return [h('div', {\n    class: 'hooper-list',\n    ref: 'list'\n  }, children)];\n}\n\nvar Slide = {\n  name: 'HooperSlide',\n  inject: ['$hooper'],\n  props: {\n    isClone: {\n      type: Boolean,\n      default: false\n    },\n    index: {\n      type: Number,\n      required: true\n    }\n  },\n  computed: {\n    style: function style() {\n      var _ref = this.$hooper || {},\n          config = _ref.config,\n          slideHeight = _ref.slideHeight,\n          slideWidth = _ref.slideWidth;\n\n      if (config.vertical) {\n        return \"height: \".concat(slideHeight, \"px\");\n      }\n\n      return \"width: \".concat(slideWidth, \"px\");\n    },\n    isActive: function isActive() {\n      var _this$$hooper$slideBo = this.$hooper.slideBounds,\n          upper = _this$$hooper$slideBo.upper,\n          lower = _this$$hooper$slideBo.lower;\n      return this.index >= lower && this.index <= upper;\n    },\n    isPrev: function isPrev() {\n      var lower = this.$hooper.slideBounds.lower;\n      var itemsToSlide = this.$hooper.config.itemsToSlide;\n      return this.index < lower && this.index >= lower - itemsToSlide;\n    },\n    isNext: function isNext() {\n      var upper = this.$hooper.slideBounds.upper;\n      var itemsToSlide = this.$hooper.config.itemsToSlide;\n      return this.index > upper && this.index <= upper + itemsToSlide;\n    },\n    isCurrent: function isCurrent() {\n      return this.index === this.$hooper.currentSlide;\n    }\n  },\n  render: function render(h) {\n    var classes = {\n      'hooper-slide': true,\n      'is-clone': this.isClone,\n      'is-active': this.isActive,\n      'is-prev': this.isPrev,\n      'is-next': this.isNext,\n      'is-current': this.isCurrent\n    };\n    var children = normalizeChildren(this);\n    return h('li', {\n      class: classes,\n      style: this.style,\n      attrs: {\n        'aria-hidden': !this.isActive\n      }\n    }, children);\n  }\n};\n\nvar Mixin = {\n  inject: ['$hooper']\n};\n\nvar icons = {\n  arrowUp: 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z',\n  arrowDown: 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z',\n  arrowRight: 'M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z',\n  arrowLeft: 'M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z'\n};\nvar Icon = {\n  name: 'HooperIcon',\n  functional: true,\n  inheritAttrs: true,\n  props: {\n    name: {\n      type: String,\n      required: true,\n      validator: function validator(val) {\n        return val in icons;\n      }\n    }\n  },\n  render: function render(createElement, _ref) {\n    var props = _ref.props;\n    var icon = icons[props.name];\n    var children = [];\n    children.push(createElement('title', camelCaseToString(props.name)));\n    children.push(createElement('path', {\n      attrs: {\n        d: 'M0 0h24v24H0z',\n        fill: 'none'\n      }\n    }));\n    children.push(createElement('path', {\n      attrs: {\n        d: icon\n      }\n    }));\n    return createElement('svg', {\n      attrs: {\n        class: \"icon icon-\".concat(props.name),\n        viewBox: '0 0 24 24',\n        width: '24px',\n        height: '24px'\n      }\n    }, children);\n  }\n};\n\nvar Progress = {\n  inject: ['$hooper'],\n  name: 'HooperProgress',\n  computed: {\n    currentSlide: function currentSlide() {\n      return normalizeSlideIndex(this.$hooper.currentSlide, this.$hooper.slidesCount);\n    },\n    progress: function progress() {\n      var range = this.$hooper.slidesCount - this.$hooper.trimStart - this.$hooper.trimEnd;\n      return (this.currentSlide - this.$hooper.trimStart) * 100 / range;\n    }\n  },\n  render: function render(h) {\n    return h('div', {\n      class: 'hooper-progress'\n    }, [h('div', {\n      class: 'hooper-progress-inner',\n      style: \"width: \".concat(this.progress, \"%\")\n    })]);\n  }\n};\n\nfunction renderFraction(h, current, totalCount) {\n  return [h('span', current + 1), h('span', '/'), h('span', totalCount)];\n}\n\nfunction renderIndicator(h, index, isCurrent, onClick) {\n  return h('li', [h('button', {\n    class: {\n      'hooper-indicator': true,\n      'is-active': isCurrent\n    },\n    on: {\n      click: onClick\n    },\n    attrs: {\n      type: 'button'\n    }\n  }, [h('span', {\n    class: 'hooper-sr-only'\n  }, \"item \".concat(index))])]);\n}\n\nfunction renderDefault(h, current, totalCount, slideToIndex) {\n  var children = [];\n\n  var _loop = function _loop(i) {\n    children.push(renderIndicator(h, i, i === current, function () {\n      return slideToIndex(i);\n    }));\n  };\n\n  for (var i = 0; i < totalCount; i++) {\n    _loop(i);\n  }\n\n  return [h('ol', {\n    class: 'hooper-indicators'\n  }, children)];\n}\n\nvar Pagination = {\n  inject: ['$hooper'],\n  name: 'HooperPagination',\n  props: {\n    mode: {\n      default: 'indicator',\n      type: String\n    }\n  },\n  computed: {\n    currentSlide: function currentSlide() {\n      return normalizeSlideIndex(this.$hooper.currentSlide, this.$hooper.slidesCount);\n    },\n    slides: function slides() {\n      var slides = this.$hooper.slides.map(function (_, index) {\n        return index;\n      });\n      return slides.slice(this.$hooper.trimStart, this.$hooper.slidesCount - this.$hooper.trimEnd + 1);\n    }\n  },\n  render: function render(h) {\n    var _this = this;\n\n    var totalCount = this.$hooper.slidesCount;\n    var children = this.mode === 'indicator' ? renderDefault(h, this.currentSlide, totalCount, function (index) {\n      return _this.$hooper.slideTo(index);\n    }) : renderFraction(h, this.currentSlide, totalCount);\n    return h('div', {\n      class: {\n        'hooper-pagination': true,\n        'is-vertical': this.$hooper.config.vertical\n      }\n    }, children);\n  }\n};\n\nfunction iconName(isVertical, isRTL, isPrev) {\n  if (isPrev) {\n    return isVertical ? 'arrowUp' : isRTL ? 'arrowRight' : 'arrowLeft';\n  }\n\n  return isVertical ? 'arrowDown' : isRTL ? 'arrowLeft' : 'arrowRight';\n}\n\nfunction renderButton(h, disabled, slot, isPrev, _ref, onClick) {\n  var _class;\n\n  var isVertical = _ref.isVertical,\n      isRTL = _ref.isRTL;\n  var children = slot && slot.length ? slot : [h(Icon, {\n    props: {\n      name: iconName(isVertical, isRTL, isPrev)\n    }\n  })];\n  return h('button', {\n    class: (_class = {}, _defineProperty(_class, \"hooper-\".concat(isPrev ? 'prev' : 'next'), true), _defineProperty(_class, 'is-disabled', disabled), _class),\n    attrs: {\n      type: 'button'\n    },\n    on: {\n      click: onClick\n    }\n  }, children);\n}\n\nvar Navigation = {\n  inject: ['$hooper'],\n  name: 'HooperNavigation',\n  computed: {\n    isPrevDisabled: function isPrevDisabled() {\n      if (this.$hooper.config.infiniteScroll) {\n        return false;\n      }\n\n      return this.$hooper.currentSlide === 0;\n    },\n    isNextDisabled: function isNextDisabled() {\n      if (this.$hooper.config.infiniteScroll) {\n        return false;\n      }\n\n      if (this.$hooper.config.trimWhiteSpace) {\n        return this.$hooper.currentSlide === this.$hooper.slidesCount - Math.min(this.$hooper.config.itemsToShow, this.$hooper.slidesCount);\n      }\n\n      return this.$hooper.currentSlide === this.$hooper.slidesCount - 1;\n    }\n  },\n  methods: {\n    slideNext: function slideNext() {\n      this.$hooper.slideNext();\n      this.$hooper.restartTimer();\n    },\n    slidePrev: function slidePrev() {\n      this.$hooper.slidePrev();\n      this.$hooper.restartTimer();\n    }\n  },\n  render: function render(h) {\n    var _this = this;\n\n    var config = {\n      isRTL: this.$hooper.config.rtl,\n      isVertical: this.$hooper.config.vertical\n    };\n    var children = [renderButton(h, this.isPrevDisabled, this.$slots['hooper-prev'], true, config, function () {\n      return _this.slidePrev();\n    }), renderButton(h, this.isNextDisabled, this.$slots['hooper-next'], false, config, function () {\n      return _this.slideNext();\n    })];\n    return h('div', {\n      class: {\n        'hooper-navigation': true,\n        'is-vertical': this.$hooper.config.vertical,\n        'is-rtl': this.$hooper.config.rtl\n      }\n    }, children);\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Carousel);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9vcGVyL2Rpc3QvaG9vcGVyLmVzbS5qcz83ZTA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDJDQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7O0FBRWhGOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBLCtEQUErRDtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIOztBQUV4SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVlLHVFQUFRLEVBQUM7QUFDMEUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG9vcGVyL2Rpc3QvaG9vcGVyLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAqIEhvcHBlciAwLjMuNFxuICAqIChjKSAyMDE5XG4gICAgKiBAbGljZW5zZSBNSVRcbiAgICAqL1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5SYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIFRpbWVyKGNhbGxiYWNrLCB0aW1lKSB7XG4gIHRoaXMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlVGltZXIoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgdGltZSk7XG4gIH07XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gc3RvcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnRUaW1lcigpIHtcbiAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIgPSB0aGlzLmNyZWF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0VGltZXIobmV3VGltZSkge1xuICAgIHRpbWUgPSBuZXdUaW1lIHx8IHRpbWU7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9O1xuXG4gIHRoaXMudGltZXIgPSB0aGlzLmNyZWF0ZSgpO1xufVxuZnVuY3Rpb24gY2FtZWxDYXNlVG9TdHJpbmcoY2FtZWxDYXNlKSB7XG4gIGNhbWVsQ2FzZSA9IGNhbWVsQ2FzZS5yZXBsYWNlKC8oW0EtWl0rKS9nLCAnICQxJyk7XG4gIHJldHVybiBjYW1lbENhc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbENhc2Uuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTbGlkZUluZGV4KGluZGV4LCBzbGlkZXNDb3VudCkge1xuICB2YXIgcmVhbEluZGV4O1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZWFsSW5kZXggPSAoaW5kZXggKyBzbGlkZXNDb3VudCkgJSBzbGlkZXNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICByZWFsSW5kZXggPSBpbmRleCAlIHNsaWRlc0NvdW50O1xuICB9IC8vIFRlc3QgZm9yIE5hTlxuXG5cbiAgaWYgKHJlYWxJbmRleCAhPT0gcmVhbEluZGV4KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVhbEluZGV4O1xufVxuZnVuY3Rpb24gY2xvbmVOb2RlKGgsIHZOb2RlKSB7XG4gIC8vIHVzZSB0aGUgY29udGV4dCB0aGF0IHRoZSBvcmlnaW5hbCB2bm9kZSB3YXMgY3JlYXRlZCBpbi5cbiAgdmFyIGNoaWxkcmVuID0gdk5vZGUuY2hpbGRyZW4gfHwgdk5vZGUuY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiB8fCB2Tm9kZS50ZXh0O1xuICB2YXIgdGFnID0gdk5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yO1xuICByZXR1cm4gaCh0YWcsIHZOb2RlLmRhdGEsIGNoaWxkcmVuKTtcbn0gLy8gSUUxMSA6KVxuXG5mdW5jdGlvbiBhc3NpZ25Qb2x5KHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXh0U291cmNlID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuXG4gICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcblxuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgYXNzaWduUG9seTtcblxuZnVuY3Rpb24gc2lnblBvbHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA+IDAgPyAxIDogMDtcbn1cblxudmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgc2lnblBvbHk7XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjb250ZXh0KSB7XG4gIHZhciBzbG90UHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmIChjb250ZXh0LiRzY29wZWRTbG90cy5kZWZhdWx0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQuJHNjb3BlZFNsb3RzLmRlZmF1bHQoc2xvdFByb3BzKSB8fCBbXTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0LiRzbG90cy5kZWZhdWx0IHx8IFtdO1xufVxuXG52YXIgRU1JVFRFUiA9IG5ldyBWdWUoKTtcbnZhciBDYXJvdXNlbCA9IHtcbiAgbmFtZTogJ0hvb3BlcicsXG4gIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICRob29wZXI6IHRoaXNcbiAgICB9O1xuICB9LFxuICBwcm9wczoge1xuICAgIC8vIGNvdW50IG9mIGl0ZW1zIHRvIHNob3dlZCBwZXIgdmlld1xuICAgIGl0ZW1zVG9TaG93OiB7XG4gICAgICBkZWZhdWx0OiAxLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICAvLyBjb3VudCBvZiBpdGVtcyB0byBzbGlkZSB3aGVuIHVzZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICBpdGVtc1RvU2xpZGU6IHtcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIC8vIGluZGV4IG51bWJlciBvZiBpbml0aWFsIHNsaWRlXG4gICAgaW5pdGlhbFNsaWRlOiB7XG4gICAgICBkZWZhdWx0OiAwLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICAvLyBjb250cm9sIGluZmluaXRlIHNjcm9sbGluZyBtb2RlXG4gICAgaW5maW5pdGVTY3JvbGw6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgLy8gY29udHJvbCBjZW50ZXIgbW9kZVxuICAgIGNlbnRlck1vZGU6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgLy8gdmVydGljYWwgc2xpZGluZyBtb2RlXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgLy8gZW5hYmxlIHJ0bCBtb2RlXG4gICAgcnRsOiB7XG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgLy8gZW5hYmxlIGF1dG8gc2xpZGluZyB0byBjYXJvdXNlbFxuICAgIGF1dG9QbGF5OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuICAgIC8vIHNwZWVkIG9mIGF1dG8gcGxheSB0byB0cmlnZ2VyIHNsaWRlXG4gICAgcGxheVNwZWVkOiB7XG4gICAgICBkZWZhdWx0OiAyMDAwLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcbiAgICAvLyB0b2dnbGUgbW91c2UgZHJhZ2dpbmdcbiAgICBtb3VzZURyYWc6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICAvLyB0b2dnbGUgdG91Y2ggZHJhZ2dpbmdcbiAgICB0b3VjaERyYWc6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICAvLyB0b2dnbGUgbW91c2Ugd2hlZWwgc2xpZGluZ1xuICAgIHdoZWVsQ29udHJvbDoge1xuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuICAgIC8vIHRvZ2dsZSBrZXlib2FyZCBjb250cm9sXG4gICAga2V5c0NvbnRyb2w6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICAvLyBlbmFibGUgYW55IG1vdmUgdG8gY29tbWl0IGEgc2xpZGVcbiAgICBzaG9ydERyYWc6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICAvLyBzbGlkaW5nIHRyYW5zaXRpb24gdGltZSBpbiBtc1xuICAgIHRyYW5zaXRpb246IHtcbiAgICAgIGRlZmF1bHQ6IDMwMCxcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG4gICAgLy8gcGF1c2UgYXV0b1BsYXkgb24gbW91c2Vob3ZlclxuICAgIGhvdmVyUGF1c2U6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICAvLyByZW1vdmUgZW1wdHkgc3BhY2UgYXJvdW5kIHNsaWRlc1xuICAgIHRyaW1XaGl0ZVNwYWNlOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuICAgIC8vIGFuIG9iamVjdCB0byBwYXNzIGFsbCBzZXR0aW5nc1xuICAgIHNldHRpbmdzOiB7XG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH0sXG4gICAgZ3JvdXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgaXNTbGlkaW5nOiBmYWxzZSxcbiAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgaXNIb3ZlcjogZmFsc2UsXG4gICAgICBpc0ZvY3VzOiBmYWxzZSxcbiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHNsaWRlV2lkdGg6IDAsXG4gICAgICBzbGlkZUhlaWdodDogMCxcbiAgICAgIHNsaWRlc0NvdW50OiAwLFxuICAgICAgdHJpbVN0YXJ0OiAwLFxuICAgICAgdHJpbUVuZDogMSxcbiAgICAgIGN1cnJlbnRTbGlkZTogbnVsbCxcbiAgICAgIHRpbWVyOiBudWxsLFxuICAgICAgZGVmYXVsdHM6IHt9LFxuICAgICAgYnJlYWtwb2ludHM6IHt9LFxuICAgICAgZGVsdGE6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIGNvbmZpZzoge31cbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNsaWRlQm91bmRzOiBmdW5jdGlvbiBzbGlkZUJvdW5kcygpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBjdXJyZW50U2xpZGUgPSB0aGlzLmN1cnJlbnRTbGlkZTsgLy8gQmVjYXVzZSB0aGUgXCJpc0FjdGl2ZVwiIGRlcGVuZHMgb24gdGhlIHNsaWRlcyBzaG93biwgbm90IHRoZSBudW1iZXIgb2Ygc2xpZGFibGUgb25lcy5cbiAgICAgIC8vIGJ1dCB1cHBlciBhbmQgbG93ZXIgYm91bmRzIGZvciBOZXh0LFByZXYgZGVwZW5kIG9uIHdoYXRldmVyIGlzIHNtYWxsZXIuXG5cbiAgICAgIHZhciBzaWJsaW5ncyA9IGNvbmZpZy5pdGVtc1RvU2hvdztcbiAgICAgIHZhciBsb3dlciA9IGNvbmZpZy5jZW50ZXJNb2RlID8gTWF0aC5jZWlsKGN1cnJlbnRTbGlkZSAtIHNpYmxpbmdzIC8gMikgOiBjdXJyZW50U2xpZGU7XG4gICAgICB2YXIgdXBwZXIgPSBjb25maWcuY2VudGVyTW9kZSA/IE1hdGguZmxvb3IoY3VycmVudFNsaWRlICsgc2libGluZ3MgLyAyKSA6IE1hdGguZmxvb3IoY3VycmVudFNsaWRlICsgc2libGluZ3MgLSAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvd2VyOiBsb3dlcixcbiAgICAgICAgdXBwZXI6IHVwcGVyXG4gICAgICB9O1xuICAgIH0sXG4gICAgdHJhY2tUcmFuc2Zvcm06IGZ1bmN0aW9uIHRyYWNrVHJhbnNmb3JtKCkge1xuICAgICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIGluZmluaXRlU2Nyb2xsID0gX3RoaXMkY29uZmlnLmluZmluaXRlU2Nyb2xsLFxuICAgICAgICAgIHZlcnRpY2FsID0gX3RoaXMkY29uZmlnLnZlcnRpY2FsLFxuICAgICAgICAgIHJ0bCA9IF90aGlzJGNvbmZpZy5ydGwsXG4gICAgICAgICAgY2VudGVyTW9kZSA9IF90aGlzJGNvbmZpZy5jZW50ZXJNb2RlO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHJ0bCA/IC0xIDogMTtcbiAgICAgIHZhciBzbGlkZUxlbmd0aCA9IHZlcnRpY2FsID8gdGhpcy5zbGlkZUhlaWdodCA6IHRoaXMuc2xpZGVXaWR0aDtcbiAgICAgIHZhciBjb250YWluZXJMZW5ndGggPSB2ZXJ0aWNhbCA/IHRoaXMuY29udGFpbmVySGVpZ2h0IDogdGhpcy5jb250YWluZXJXaWR0aDtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSB2ZXJ0aWNhbCA/IHRoaXMuZGVsdGEueSA6IHRoaXMuZGVsdGEueDtcbiAgICAgIHZhciBjbG9uZXNTcGFjZSA9IGluZmluaXRlU2Nyb2xsID8gc2xpZGVMZW5ndGggKiB0aGlzLnNsaWRlc0NvdW50IDogMDtcbiAgICAgIHZhciBjZW50ZXJpbmdTcGFjZSA9IGNlbnRlck1vZGUgPyAoY29udGFpbmVyTGVuZ3RoIC0gc2xpZGVMZW5ndGgpIC8gMiA6IDA7IC8vIGNhbGN1bGF0ZSB0cmFjayB0cmFuc2xhdGVcblxuICAgICAgdmFyIHRyYW5zbGF0ZSA9IGRyYWdEZWx0YSArIGRpcmVjdGlvbiAqIChjZW50ZXJpbmdTcGFjZSAtIGNsb25lc1NwYWNlIC0gdGhpcy5jdXJyZW50U2xpZGUgKiBzbGlkZUxlbmd0aCk7XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCBcIi5jb25jYXQodHJhbnNsYXRlLCBcInB4KTtcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInRyYW5zZm9ybTogdHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2xhdGUsIFwicHgsIDApO1wiKTtcbiAgICB9LFxuICAgIHRyYWNrVHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhY2tUcmFuc2l0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgJiYgdGhpcy5pc1NsaWRpbmcpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNpdGlvbjogXCIuY29uY2F0KHRoaXMuY29uZmlnLnRyYW5zaXRpb24sIFwibXNcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKHZhbCwgb2xkVmFsKSB7XG4gICAgICBpZiAodmFsID09PSBvbGRWYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBFTUlUVEVSLiRvZmYoXCJzbGlkZUdyb3VwOlwiLmNvbmNhdChvbGRWYWwpLCB0aGlzLl9ncm91cFNsaWRlSGFuZGxlcik7XG4gICAgICB0aGlzLmFkZEdyb3VwTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLy8gY29udHJvbGxpbmcgbWV0aG9kc1xuICAgIHNsaWRlVG86IGZ1bmN0aW9uIHNsaWRlVG8oc2xpZGVJbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGlzU291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5pc1NsaWRpbmcgfHwgc2xpZGVJbmRleCA9PT0gdGhpcy5jdXJyZW50U2xpZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbWl0KCdiZWZvcmVTbGlkZScsIHtcbiAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLmN1cnJlbnRTbGlkZSxcbiAgICAgICAgc2xpZGVUbzogaW5kZXhcbiAgICAgIH0pO1xuICAgICAgdmFyIF90aGlzJGNvbmZpZzIgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBpbmZpbml0ZVNjcm9sbCA9IF90aGlzJGNvbmZpZzIuaW5maW5pdGVTY3JvbGwsXG4gICAgICAgICAgdHJhbnNpdGlvbiA9IF90aGlzJGNvbmZpZzIudHJhbnNpdGlvbjtcbiAgICAgIHZhciBwcmV2aW91c1NsaWRlID0gdGhpcy5jdXJyZW50U2xpZGU7XG4gICAgICB2YXIgaW5kZXggPSBpbmZpbml0ZVNjcm9sbCA/IHNsaWRlSW5kZXggOiBnZXRJblJhbmdlKHNsaWRlSW5kZXgsIHRoaXMudHJpbVN0YXJ0LCB0aGlzLnNsaWRlc0NvdW50IC0gdGhpcy50cmltRW5kKTsgLy8gTm90aWZ5IG90aGVycyBpZiBpbiBhIGdyb3VwIGFuZCBpcyB0aGUgc2xpZGUgZXZlbnQgaW5pdGlhdG9yLlxuXG4gICAgICBpZiAodGhpcy5ncm91cCAmJiBpc1NvdXJjZSkge1xuICAgICAgICBFTUlUVEVSLiRlbWl0KFwic2xpZGVHcm91cDpcIi5jb25jYXQodGhpcy5ncm91cCksIHNsaWRlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IGluZGV4O1xuICAgICAgdGhpcy5pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY3VycmVudFNsaWRlID0gbm9ybWFsaXplU2xpZGVJbmRleChpbmRleCwgX3RoaXMuc2xpZGVzQ291bnQpO1xuICAgICAgfSwgdHJhbnNpdGlvbik7XG4gICAgICB0aGlzLiRlbWl0KCdzbGlkZScsIHtcbiAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLmN1cnJlbnRTbGlkZSxcbiAgICAgICAgc2xpZGVGcm9tOiBwcmV2aW91c1NsaWRlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNsaWRlTmV4dDogZnVuY3Rpb24gc2xpZGVOZXh0KCkge1xuICAgICAgdGhpcy5zbGlkZVRvKHRoaXMuY3VycmVudFNsaWRlICsgdGhpcy5jb25maWcuaXRlbXNUb1NsaWRlKTtcbiAgICB9LFxuICAgIHNsaWRlUHJldjogZnVuY3Rpb24gc2xpZGVQcmV2KCkge1xuICAgICAgdGhpcy5zbGlkZVRvKHRoaXMuY3VycmVudFNsaWRlIC0gdGhpcy5jb25maWcuaXRlbXNUb1NsaWRlKTtcbiAgICB9LFxuICAgIGluaXRFdmVudHM6IGZ1bmN0aW9uIGluaXRFdmVudHMoKSB7XG4gICAgICAvLyBnZXQgdGhlIGVsZW1lbnQgZGlyZWN0aW9uIGlmIG5vdCBleHBsaWNpdGx5IHNldFxuICAgICAgaWYgKHRoaXMuZGVmYXVsdHMucnRsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMucnRsID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9QbGF5KSB7XG4gICAgICAgIHRoaXMuaW5pdEF1dG9QbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZURyYWcpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25maWcudG91Y2hEcmFnKSB7XG4gICAgICAgIHRoaXMuJHJlZnMubGlzdC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRyYWdTdGFydCwge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5rZXlzQ29udHJvbCkge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleXByZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29uZmlnLndoZWVsQ29udHJvbCkge1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUaW1lID0gbm93KCk7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgfSxcbiAgICBpbml0QXV0b1BsYXk6IGZ1bmN0aW9uIGluaXRBdXRvUGxheSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5pc1NsaWRpbmcgfHwgX3RoaXMyLmlzRHJhZ2dpbmcgfHwgX3RoaXMyLmlzSG92ZXIgJiYgX3RoaXMyLmNvbmZpZy5ob3ZlclBhdXNlIHx8IF90aGlzMi5pc0ZvY3VzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzMi5jdXJyZW50U2xpZGUgPT09IF90aGlzMi5zbGlkZXNDb3VudCAtIDEgJiYgIV90aGlzMi5jb25maWcuaW5maW5pdGVTY3JvbGwpIHtcbiAgICAgICAgICBfdGhpczIuc2xpZGVUbygwKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5zbGlkZU5leHQoKTtcbiAgICAgIH0sIHRoaXMuY29uZmlnLnBsYXlTcGVlZCk7XG4gICAgfSxcbiAgICBpbml0RGVmYXVsdHM6IGZ1bmN0aW9uIGluaXREZWZhdWx0cygpIHtcbiAgICAgIHRoaXMuYnJlYWtwb2ludHMgPSB0aGlzLnNldHRpbmdzLmJyZWFrcG9pbnRzO1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IGFzc2lnbih7fSwgdGhpcy4kcHJvcHMsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5jb25maWcgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMpO1xuICAgIH0sXG4gICAgLy8gdXBkYXRpbmcgbWV0aG9kc1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKHRoaXMuYnJlYWtwb2ludHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgICAgdGhpcy51cGRhdGVUcmltKCk7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGVkJywge1xuICAgICAgICBjb250YWluZXJXaWR0aDogdGhpcy5jb250YWluZXJXaWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgc2xpZGVXaWR0aDogdGhpcy5zbGlkZVdpZHRoLFxuICAgICAgICBzbGlkZUhlaWdodDogdGhpcy5zbGlkZUhlaWdodCxcbiAgICAgICAgc2V0dGluZ3M6IHRoaXMuY29uZmlnXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVRyaW06IGZ1bmN0aW9uIHVwZGF0ZVRyaW0oKSB7XG4gICAgICB2YXIgX3RoaXMkY29uZmlnMyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIHRyaW1XaGl0ZVNwYWNlID0gX3RoaXMkY29uZmlnMy50cmltV2hpdGVTcGFjZSxcbiAgICAgICAgICBpdGVtc1RvU2hvdyA9IF90aGlzJGNvbmZpZzMuaXRlbXNUb1Nob3csXG4gICAgICAgICAgY2VudGVyTW9kZSA9IF90aGlzJGNvbmZpZzMuY2VudGVyTW9kZSxcbiAgICAgICAgICBpbmZpbml0ZVNjcm9sbCA9IF90aGlzJGNvbmZpZzMuaW5maW5pdGVTY3JvbGw7XG5cbiAgICAgIGlmICghdHJpbVdoaXRlU3BhY2UgfHwgaW5maW5pdGVTY3JvbGwpIHtcbiAgICAgICAgdGhpcy50cmltU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnRyaW1FbmQgPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpbVN0YXJ0ID0gY2VudGVyTW9kZSA/IE1hdGguZmxvb3IoKGl0ZW1zVG9TaG93IC0gMSkgLyAyKSA6IDA7XG4gICAgICB0aGlzLnRyaW1FbmQgPSBjZW50ZXJNb2RlID8gTWF0aC5jZWlsKGl0ZW1zVG9TaG93IC8gMikgOiBpdGVtc1RvU2hvdztcbiAgICB9LFxuICAgIHVwZGF0ZVdpZHRoOiBmdW5jdGlvbiB1cGRhdGVXaWR0aCgpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy52ZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLnNsaWRlSGVpZ2h0ID0gdGhpcy5jb250YWluZXJIZWlnaHQgLyB0aGlzLmNvbmZpZy5pdGVtc1RvU2hvdztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNsaWRlV2lkdGggPSB0aGlzLmNvbnRhaW5lcldpZHRoIC8gdGhpcy5jb25maWcuaXRlbXNUb1Nob3c7XG4gICAgfSxcbiAgICB1cGRhdGVDb25maWc6IGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgYnJlYWtwb2ludHMgPSBPYmplY3Qua2V5cyh0aGlzLmJyZWFrcG9pbnRzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1hdGNoZWQ7XG4gICAgICBicmVha3BvaW50cy5zb21lKGZ1bmN0aW9uIChicmVha3BvaW50KSB7XG4gICAgICAgIG1hdGNoZWQgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihtaW4td2lkdGg6IFwiLmNvbmNhdChicmVha3BvaW50LCBcInB4KVwiKSkubWF0Y2hlcztcblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIF90aGlzMy5jb25maWcgPSBhc3NpZ24oe30sIF90aGlzMy5jb25maWcsIF90aGlzMy5kZWZhdWx0cywgX3RoaXMzLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGFzc2lnbih0aGlzLmNvbmZpZywgdGhpcy5kZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXN0YXJ0VGltZXI6IGZ1bmN0aW9uIHJlc3RhcnRUaW1lcigpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzdGFydDogZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC51cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gZXZlbnRzIGhhbmRsZXJzXG4gICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICB0aGlzLmlzVG91Y2ggPSBldmVudC50eXBlID09PSAndG91Y2hzdGFydCc7XG5cbiAgICAgIGlmICghdGhpcy5pc1RvdWNoICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIHRoaXMuZW5kUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uLnggPSB0aGlzLmlzVG91Y2ggPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uLnkgPSB0aGlzLmlzVG91Y2ggPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFkgOiBldmVudC5jbGllbnRZO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmlzVG91Y2ggPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnLCB0aGlzLm9uRHJhZyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuaXNUb3VjaCA/ICd0b3VjaGVuZCcgOiAnbW91c2V1cCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICB9LFxuICAgIGlzSW52YWxpZERpcmVjdGlvbjogZnVuY3Rpb24gaXNJbnZhbGlkRGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlnLnZlcnRpY2FsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhkZWx0YVgpIDw9IE1hdGguYWJzKGRlbHRhWSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy52ZXJ0aWNhbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGVsdGFZKSA8PSBNYXRoLmFicyhkZWx0YVgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZyhldmVudCkge1xuICAgICAgaWYgKHRoaXMuaXNTbGlkaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbmRQb3NpdGlvbi54ID0gdGhpcy5pc1RvdWNoID8gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuZW5kUG9zaXRpb24ueSA9IHRoaXMuaXNUb3VjaCA/IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2ZW50LmNsaWVudFk7XG4gICAgICB2YXIgZGVsdGFYID0gdGhpcy5lbmRQb3NpdGlvbi54IC0gdGhpcy5zdGFydFBvc2l0aW9uLng7XG4gICAgICB2YXIgZGVsdGFZID0gdGhpcy5lbmRQb3NpdGlvbi55IC0gdGhpcy5zdGFydFBvc2l0aW9uLnk7IC8vIE1heWJlIHNjcm9sbGluZy5cblxuICAgICAgaWYgKHRoaXMuaXNJbnZhbGlkRGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsdGEueSA9IGRlbHRhWTtcbiAgICAgIHRoaXMuZGVsdGEueCA9IGRlbHRhWDtcblxuICAgICAgaWYgKCF0aGlzLmlzVG91Y2gpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IHRoaXMuY29uZmlnLnNob3J0RHJhZyA/IDAuNSA6IDAuMTU7XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnZlcnRpY2FsKSB7XG4gICAgICAgIHZhciBkcmFnZ2VkU2xpZGVzID0gTWF0aC5yb3VuZChNYXRoLmFicyh0aGlzLmRlbHRhLnkgLyB0aGlzLnNsaWRlSGVpZ2h0KSArIHRvbGVyYW5jZSk7XG4gICAgICAgIHRoaXMuc2xpZGVUbyh0aGlzLmN1cnJlbnRTbGlkZSAtIHNpZ24odGhpcy5kZWx0YS55KSAqIGRyYWdnZWRTbGlkZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLnZlcnRpY2FsKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAodGhpcy5jb25maWcucnRsID8gLTEgOiAxKSAqIHNpZ24odGhpcy5kZWx0YS54KTtcblxuICAgICAgICB2YXIgX2RyYWdnZWRTbGlkZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKHRoaXMuZGVsdGEueCAvIHRoaXMuc2xpZGVXaWR0aCkgKyB0b2xlcmFuY2UpO1xuXG4gICAgICAgIHRoaXMuc2xpZGVUbyh0aGlzLmN1cnJlbnRTbGlkZSAtIGRpcmVjdGlvbiAqIF9kcmFnZ2VkU2xpZGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWx0YS54ID0gMDtcbiAgICAgIHRoaXMuZGVsdGEueSA9IDA7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuaXNUb3VjaCA/ICd0b3VjaG1vdmUnIDogJ21vdXNlbW92ZScsIHRoaXMub25EcmFnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5pc1RvdWNoID8gJ3RvdWNoZW5kJyA6ICdtb3VzZXVwJywgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICB9LFxuICAgIG9uVHJhbnNpdGlvbmVuZDogZnVuY3Rpb24gb25UcmFuc2l0aW9uZW5kKCkge1xuICAgICAgdGhpcy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuJGVtaXQoJ2FmdGVyU2xpZGUnLCB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5jdXJyZW50U2xpZGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25LZXlwcmVzczogZnVuY3Rpb24gb25LZXlwcmVzcyhldmVudCkge1xuICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcblxuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdBcnJvdycpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy52ZXJ0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICB0aGlzLnNsaWRlUHJldigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICB0aGlzLnNsaWRlTmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25maWcucnRsKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuc2xpZGVQcmV2KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICAgIHRoaXMuc2xpZGVOZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICB0aGlzLnNsaWRlTmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICB0aGlzLnNsaWRlUHJldigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25XaGVlbDogZnVuY3Rpb24gb25XaGVlbChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKG5vdygpIC0gdGhpcy5sYXN0U2Nyb2xsVGltZSA8IDIwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCB3aGVlbCBkaXJlY3Rpb25cblxuXG4gICAgICB0aGlzLmxhc3RTY3JvbGxUaW1lID0gbm93KCk7XG4gICAgICB2YXIgdmFsdWUgPSBldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZWx0YVk7XG4gICAgICB2YXIgZGVsdGEgPSBzaWduKHZhbHVlKTtcblxuICAgICAgaWYgKGRlbHRhID09PSAtMSkge1xuICAgICAgICB0aGlzLnNsaWRlTmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsdGEgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zbGlkZVByZXYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZEdyb3VwTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGRHcm91cExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ncm91cFNsaWRlSGFuZGxlciA9IGZ1bmN0aW9uIChzbGlkZUluZGV4KSB7XG4gICAgICAgIC8vIHNldCB0aGUgaXNTb3VyY2UgdG8gZmFsc2UgdG8gcHJldmVudCBpbmZpbml0ZSBlbWl0dGluZyBsb29wLlxuICAgICAgICBfdGhpczUuc2xpZGVUbyhzbGlkZUluZGV4LCBmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICBFTUlUVEVSLiRvbihcInNsaWRlR3JvdXA6XCIuY29uY2F0KHRoaXMuZ3JvdXApLCB0aGlzLl9ncm91cFNsaWRlSGFuZGxlcik7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuaW5pdERlZmF1bHRzKCk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB0aGlzLmluaXRFdmVudHMoKTtcbiAgICB0aGlzLmFkZEdyb3VwTGlzdGVuZXJzKCk7XG4gICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM2LnVwZGF0ZSgpO1xuXG4gICAgICBfdGhpczYuc2xpZGVUbyhfdGhpczYuY29uZmlnLmluaXRpYWxTbGlkZSB8fCAwKTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi4kZW1pdCgnbG9hZGVkJyk7XG5cbiAgICAgICAgX3RoaXM2LmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH0sIF90aGlzNi50cmFuc2l0aW9uKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGUpO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIEVNSVRURVIuJG9mZihcInNsaWRlR3JvdXA6XCIuY29uY2F0KHRoaXMuZ3JvdXApLCB0aGlzLl9ncm91cFNsaWRlSGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIuc3RvcCgpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdmFyIGJvZHkgPSByZW5kZXJCb2R5LmNhbGwodGhpcywgaCk7XG4gICAgcmV0dXJuIGgoJ3NlY3Rpb24nLCB7XG4gICAgICBjbGFzczoge1xuICAgICAgICBob29wZXI6IHRydWUsXG4gICAgICAgICdpcy12ZXJ0aWNhbCc6IHRoaXMuY29uZmlnLnZlcnRpY2FsLFxuICAgICAgICAnaXMtcnRsJzogdGhpcy5jb25maWcucnRsXG4gICAgICB9LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdGFiaW5kZXg6ICcwJ1xuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGZvY3VzaW46IGZ1bmN0aW9uIGZvY3VzaW4oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy5pc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNvdXQ6IGZ1bmN0aW9uIGZvY3Vzb3V0KCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczcuaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uIG1vdXNlb3ZlcigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LmlzSG92ZXIgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczcuaXNIb3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgYm9keSk7XG4gIH1cbn07XG4vKipcbiAqIFJlbmRlcnMgYWRkaXRpb25hbCBzbGlkZXMgZm9yIGluZmluaXRlIHNsaWRlcyBtb2RlLlxuICogQnkgY2xvbmluZyBTbGlkZXMgVk5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXIgZWl0aGVyIGVkZ2VzLlxuICovXG5cbmZ1bmN0aW9uIHJlbmRlckJ1ZmZlclNsaWRlcyhoLCBzbGlkZXMpIHtcbiAgdmFyIGJlZm9yZSA9IFtdO1xuICB2YXIgYWZ0ZXIgPSBbXTsgLy8gcmVkdWNlIHByb3AgYWNjZXNzXG5cbiAgdmFyIHNsaWRlc0NvdW50ID0gc2xpZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlc0NvdW50OyBpKyspIHtcbiAgICB2YXIgc2xpZGUgPSBzbGlkZXNbaV07XG4gICAgdmFyIGNsb25lZEJlZm9yZSA9IGNsb25lTm9kZShoLCBzbGlkZSk7XG4gICAgdmFyIHNsaWRlSW5kZXggPSBpIC0gc2xpZGVzQ291bnQ7XG4gICAgY2xvbmVkQmVmb3JlLmRhdGEua2V5ID0gXCJiZWZvcmVfXCIuY29uY2F0KGkpO1xuICAgIGNsb25lZEJlZm9yZS5rZXkgPSBjbG9uZWRCZWZvcmUuZGF0YS5rZXk7XG4gICAgY2xvbmVkQmVmb3JlLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLmluZGV4ID0gc2xpZGVJbmRleDtcbiAgICBjbG9uZWRCZWZvcmUuZGF0YS5wcm9wcyA9IHtcbiAgICAgIGluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgIH07XG4gICAgYmVmb3JlLnB1c2goY2xvbmVkQmVmb3JlKTtcbiAgICB2YXIgY2xvbmVkQWZ0ZXIgPSBjbG9uZU5vZGUoaCwgc2xpZGUpO1xuICAgIHNsaWRlSW5kZXggPSBpICsgc2xpZGVzQ291bnQ7XG4gICAgY2xvbmVkQWZ0ZXIuZGF0YS5rZXkgPSBcImFmdGVyX1wiLmNvbmNhdChzbGlkZUluZGV4KTtcbiAgICBjbG9uZWRBZnRlci5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YS5pbmRleCA9IHNsaWRlSW5kZXg7XG4gICAgY2xvbmVkQWZ0ZXIua2V5ID0gY2xvbmVkQWZ0ZXIuZGF0YS5rZXk7XG4gICAgY2xvbmVkQWZ0ZXIuZGF0YS5wcm9wcyA9IHtcbiAgICAgIGluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgIH07XG4gICAgYWZ0ZXIucHVzaChjbG9uZWRBZnRlcik7XG4gIH1cblxuICByZXR1cm4gW10uY29uY2F0KGJlZm9yZSwgX3RvQ29uc3VtYWJsZUFycmF5KHNsaWRlcyksIGFmdGVyKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgdGhlIFZOb2RlcyBmb3IgdGhlIFNsaWRlcy5cbiAqIHJlcXVpcmVzIHt0aGlzfSB0byBiZSBib3VuZCB0byBob29wZXIuXG4gKiBTbyB1c2Ugd2l0aCAuY2FsbCBvciAuYmluZFxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyU2xpZGVzKGgpIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4odGhpcyk7XG4gIHZhciBjaGlsZHJlbkNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIHNsaWRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5Db3VudDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGN0b3IgPSBjaGlsZC5jb21wb25lbnRPcHRpb25zICYmIGNoaWxkLmNvbXBvbmVudE9wdGlvbnMuQ3RvcjtcblxuICAgIGlmICghY3RvciB8fCBjdG9yLm9wdGlvbnMubmFtZSAhPT0gJ0hvb3BlclNsaWRlJykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBnaXZlIHNsaWRlIGFuIGluZGV4IGJlaGluZCB0aGUgc2NlbmVzXG5cblxuICAgIGNoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLmluZGV4ID0gaWR4O1xuICAgIGNoaWxkLmRhdGEua2V5ID0gaWR4O1xuICAgIGNoaWxkLmtleSA9IGlkeDtcbiAgICBjaGlsZC5kYXRhLnByb3BzID0gX29iamVjdFNwcmVhZCh7fSwgY2hpbGQuZGF0YS5wcm9wcyB8fCB7fSwge1xuICAgICAgaXNDbG9uZTogZmFsc2UsXG4gICAgICBpbmRleDogaWR4KytcbiAgICB9KTtcbiAgICBzbGlkZXMucHVzaChjaGlsZCk7XG4gIH0gLy8gdXBkYXRlIGhvb3BlcidzIGluZm9ybWF0aW9uIG9mIHRoZSBzbGlkZSBjb3VudC5cblxuXG4gIHRoaXMuc2xpZGVzQ291bnQgPSBzbGlkZXMubGVuZ3RoO1xuXG4gIGlmICh0aGlzLmNvbmZpZy5pbmZpbml0ZVNjcm9sbCkge1xuICAgIHNsaWRlcyA9IHJlbmRlckJ1ZmZlclNsaWRlcyhoLCBzbGlkZXMpO1xuICB9XG5cbiAgcmV0dXJuIGgoJ3VsJywge1xuICAgIGNsYXNzOiB7XG4gICAgICAnaG9vcGVyLXRyYWNrJzogdHJ1ZSxcbiAgICAgICdpcy1kcmFnZ2luZyc6IHRoaXMuaXNEcmFnZ2luZ1xuICAgIH0sXG4gICAgc3R5bGU6IHRoaXMudHJhY2tUcmFuc2Zvcm0gKyB0aGlzLnRyYWNrVHJhbnNpdGlvbixcbiAgICByZWY6ICd0cmFjaycsXG4gICAgb246IHtcbiAgICAgIHRyYW5zaXRpb25lbmQ6IHRoaXMub25UcmFuc2l0aW9uZW5kXG4gICAgfVxuICB9LCBzbGlkZXMpO1xufVxuLyoqXG4gKiBCdWlsZHMgdGhlIFZOb2RlcyBmb3IgdGhlIGhvb3BlciBib2R5LlxuICogV2hpY2ggaXMgdGhlIHNsaWRlcywgYWRkb25zIGlmIGF2YWlsYWJsZSwgYW5kIGExMXkgc3R1ZmYuXG4gKiBSRVFVSVJFUyB7dGhpc30gdG8gYmUgYm91bmQgdG8gdGhlIGhvb3BlciBpbnN0YW5jZS5cbiAqIHVzZSB3aXRoIC5jYWxsIG9yIC5iaW5kXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJCb2R5KGgpIHtcbiAgdmFyIHNsaWRlcyA9IHJlbmRlclNsaWRlcy5jYWxsKHRoaXMsIGgpO1xuICB2YXIgYWRkb25zID0gdGhpcy4kc2xvdHNbJ2hvb3Blci1hZGRvbnMnXSB8fCBbXTtcbiAgdmFyIGExMXkgPSBoKCdkaXYnLCB7XG4gICAgY2xhc3M6ICdob29wZXItbGl2ZXJlZ2lvbiBob29wZXItc3Itb25seScsXG4gICAgYXR0cnM6IHtcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJyxcbiAgICAgICdhcmlhLWF0b21pYyc6ICd0cnVlJ1xuICAgIH1cbiAgfSwgXCJJdGVtIFwiLmNvbmNhdCh0aGlzLmN1cnJlbnRTbGlkZSArIDEsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5zbGlkZXNDb3VudCkpO1xuICB2YXIgY2hpbGRyZW4gPSBbc2xpZGVzXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFkZG9ucyksIFthMTF5XSk7XG4gIHJldHVybiBbaCgnZGl2Jywge1xuICAgIGNsYXNzOiAnaG9vcGVyLWxpc3QnLFxuICAgIHJlZjogJ2xpc3QnXG4gIH0sIGNoaWxkcmVuKV07XG59XG5cbnZhciBTbGlkZSA9IHtcbiAgbmFtZTogJ0hvb3BlclNsaWRlJyxcbiAgaW5qZWN0OiBbJyRob29wZXInXSxcbiAgcHJvcHM6IHtcbiAgICBpc0Nsb25lOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUoKSB7XG4gICAgICB2YXIgX3JlZiA9IHRoaXMuJGhvb3BlciB8fCB7fSxcbiAgICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgICAgICBzbGlkZUhlaWdodCA9IF9yZWYuc2xpZGVIZWlnaHQsXG4gICAgICAgICAgc2xpZGVXaWR0aCA9IF9yZWYuc2xpZGVXaWR0aDtcblxuICAgICAgaWYgKGNvbmZpZy52ZXJ0aWNhbCkge1xuICAgICAgICByZXR1cm4gXCJoZWlnaHQ6IFwiLmNvbmNhdChzbGlkZUhlaWdodCwgXCJweFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwid2lkdGg6IFwiLmNvbmNhdChzbGlkZVdpZHRoLCBcInB4XCIpO1xuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgdmFyIF90aGlzJCRob29wZXIkc2xpZGVCbyA9IHRoaXMuJGhvb3Blci5zbGlkZUJvdW5kcyxcbiAgICAgICAgICB1cHBlciA9IF90aGlzJCRob29wZXIkc2xpZGVCby51cHBlcixcbiAgICAgICAgICBsb3dlciA9IF90aGlzJCRob29wZXIkc2xpZGVCby5sb3dlcjtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IGxvd2VyICYmIHRoaXMuaW5kZXggPD0gdXBwZXI7XG4gICAgfSxcbiAgICBpc1ByZXY6IGZ1bmN0aW9uIGlzUHJldigpIHtcbiAgICAgIHZhciBsb3dlciA9IHRoaXMuJGhvb3Blci5zbGlkZUJvdW5kcy5sb3dlcjtcbiAgICAgIHZhciBpdGVtc1RvU2xpZGUgPSB0aGlzLiRob29wZXIuY29uZmlnLml0ZW1zVG9TbGlkZTtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4IDwgbG93ZXIgJiYgdGhpcy5pbmRleCA+PSBsb3dlciAtIGl0ZW1zVG9TbGlkZTtcbiAgICB9LFxuICAgIGlzTmV4dDogZnVuY3Rpb24gaXNOZXh0KCkge1xuICAgICAgdmFyIHVwcGVyID0gdGhpcy4kaG9vcGVyLnNsaWRlQm91bmRzLnVwcGVyO1xuICAgICAgdmFyIGl0ZW1zVG9TbGlkZSA9IHRoaXMuJGhvb3Blci5jb25maWcuaXRlbXNUb1NsaWRlO1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPiB1cHBlciAmJiB0aGlzLmluZGV4IDw9IHVwcGVyICsgaXRlbXNUb1NsaWRlO1xuICAgIH0sXG4gICAgaXNDdXJyZW50OiBmdW5jdGlvbiBpc0N1cnJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy4kaG9vcGVyLmN1cnJlbnRTbGlkZTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHtcbiAgICAgICdob29wZXItc2xpZGUnOiB0cnVlLFxuICAgICAgJ2lzLWNsb25lJzogdGhpcy5pc0Nsb25lLFxuICAgICAgJ2lzLWFjdGl2ZSc6IHRoaXMuaXNBY3RpdmUsXG4gICAgICAnaXMtcHJldic6IHRoaXMuaXNQcmV2LFxuICAgICAgJ2lzLW5leHQnOiB0aGlzLmlzTmV4dCxcbiAgICAgICdpcy1jdXJyZW50JzogdGhpcy5pc0N1cnJlbnRcbiAgICB9O1xuICAgIHZhciBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKHRoaXMpO1xuICAgIHJldHVybiBoKCdsaScsIHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzLFxuICAgICAgc3R5bGU6IHRoaXMuc3R5bGUsXG4gICAgICBhdHRyczoge1xuICAgICAgICAnYXJpYS1oaWRkZW4nOiAhdGhpcy5pc0FjdGl2ZVxuICAgICAgfVxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxufTtcblxudmFyIE1peGluID0ge1xuICBpbmplY3Q6IFsnJGhvb3BlciddXG59O1xuXG52YXIgaWNvbnMgPSB7XG4gIGFycm93VXA6ICdNNy40MSAxNS40MUwxMiAxMC44M2w0LjU5IDQuNThMMTggMTRsLTYtNi02IDZ6JyxcbiAgYXJyb3dEb3duOiAnTTcuNDEgOC41OUwxMiAxMy4xN2w0LjU5LTQuNThMMTggMTBsLTYgNi02LTYgMS40MS0xLjQxeicsXG4gIGFycm93UmlnaHQ6ICdNOC41OSAxNi41OUwxMy4xNyAxMiA4LjU5IDcuNDEgMTAgNmw2IDYtNiA2LTEuNDEtMS40MXonLFxuICBhcnJvd0xlZnQ6ICdNMTUuNDEgMTYuNTlMMTAuODMgMTJsNC41OC00LjU5TDE0IDZsLTYgNiA2IDYgMS40MS0xLjQxeidcbn07XG52YXIgSWNvbiA9IHtcbiAgbmFtZTogJ0hvb3Blckljb24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBpbmhlcml0QXR0cnM6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbiBpY29ucztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQsIF9yZWYpIHtcbiAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgIHZhciBpY29uID0gaWNvbnNbcHJvcHMubmFtZV07XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KCd0aXRsZScsIGNhbWVsQ2FzZVRvU3RyaW5nKHByb3BzLm5hbWUpKSk7XG4gICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgZDogJ00wIDBoMjR2MjRIMHonLFxuICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgZDogaWNvblxuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3ZnJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6IFwiaWNvbiBpY29uLVwiLmNvbmNhdChwcm9wcy5uYW1lKSxcbiAgICAgICAgdmlld0JveDogJzAgMCAyNCAyNCcsXG4gICAgICAgIHdpZHRoOiAnMjRweCcsXG4gICAgICAgIGhlaWdodDogJzI0cHgnXG4gICAgICB9XG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG59O1xuXG52YXIgUHJvZ3Jlc3MgPSB7XG4gIGluamVjdDogWyckaG9vcGVyJ10sXG4gIG5hbWU6ICdIb29wZXJQcm9ncmVzcycsXG4gIGNvbXB1dGVkOiB7XG4gICAgY3VycmVudFNsaWRlOiBmdW5jdGlvbiBjdXJyZW50U2xpZGUoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2xpZGVJbmRleCh0aGlzLiRob29wZXIuY3VycmVudFNsaWRlLCB0aGlzLiRob29wZXIuc2xpZGVzQ291bnQpO1xuICAgIH0sXG4gICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy4kaG9vcGVyLnNsaWRlc0NvdW50IC0gdGhpcy4kaG9vcGVyLnRyaW1TdGFydCAtIHRoaXMuJGhvb3Blci50cmltRW5kO1xuICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTbGlkZSAtIHRoaXMuJGhvb3Blci50cmltU3RhcnQpICogMTAwIC8gcmFuZ2U7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiAnaG9vcGVyLXByb2dyZXNzJ1xuICAgIH0sIFtoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ2hvb3Blci1wcm9ncmVzcy1pbm5lcicsXG4gICAgICBzdHlsZTogXCJ3aWR0aDogXCIuY29uY2F0KHRoaXMucHJvZ3Jlc3MsIFwiJVwiKVxuICAgIH0pXSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckZyYWN0aW9uKGgsIGN1cnJlbnQsIHRvdGFsQ291bnQpIHtcbiAgcmV0dXJuIFtoKCdzcGFuJywgY3VycmVudCArIDEpLCBoKCdzcGFuJywgJy8nKSwgaCgnc3BhbicsIHRvdGFsQ291bnQpXTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySW5kaWNhdG9yKGgsIGluZGV4LCBpc0N1cnJlbnQsIG9uQ2xpY2spIHtcbiAgcmV0dXJuIGgoJ2xpJywgW2goJ2J1dHRvbicsIHtcbiAgICBjbGFzczoge1xuICAgICAgJ2hvb3Blci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgJ2lzLWFjdGl2ZSc6IGlzQ3VycmVudFxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIGNsaWNrOiBvbkNsaWNrXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICB9XG4gIH0sIFtoKCdzcGFuJywge1xuICAgIGNsYXNzOiAnaG9vcGVyLXNyLW9ubHknXG4gIH0sIFwiaXRlbSBcIi5jb25jYXQoaW5kZXgpKV0pXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRlZmF1bHQoaCwgY3VycmVudCwgdG90YWxDb3VudCwgc2xpZGVUb0luZGV4KSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICBjaGlsZHJlbi5wdXNoKHJlbmRlckluZGljYXRvcihoLCBpLCBpID09PSBjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2xpZGVUb0luZGV4KGkpO1xuICAgIH0pKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQ291bnQ7IGkrKykge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIFtoKCdvbCcsIHtcbiAgICBjbGFzczogJ2hvb3Blci1pbmRpY2F0b3JzJ1xuICB9LCBjaGlsZHJlbildO1xufVxuXG52YXIgUGFnaW5hdGlvbiA9IHtcbiAgaW5qZWN0OiBbJyRob29wZXInXSxcbiAgbmFtZTogJ0hvb3BlclBhZ2luYXRpb24nLFxuICBwcm9wczoge1xuICAgIG1vZGU6IHtcbiAgICAgIGRlZmF1bHQ6ICdpbmRpY2F0b3InLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGN1cnJlbnRTbGlkZTogZnVuY3Rpb24gY3VycmVudFNsaWRlKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsaWRlSW5kZXgodGhpcy4kaG9vcGVyLmN1cnJlbnRTbGlkZSwgdGhpcy4kaG9vcGVyLnNsaWRlc0NvdW50KTtcbiAgICB9LFxuICAgIHNsaWRlczogZnVuY3Rpb24gc2xpZGVzKCkge1xuICAgICAgdmFyIHNsaWRlcyA9IHRoaXMuJGhvb3Blci5zbGlkZXMubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzbGlkZXMuc2xpY2UodGhpcy4kaG9vcGVyLnRyaW1TdGFydCwgdGhpcy4kaG9vcGVyLnNsaWRlc0NvdW50IC0gdGhpcy4kaG9vcGVyLnRyaW1FbmQgKyAxKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvdGFsQ291bnQgPSB0aGlzLiRob29wZXIuc2xpZGVzQ291bnQ7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5tb2RlID09PSAnaW5kaWNhdG9yJyA/IHJlbmRlckRlZmF1bHQoaCwgdGhpcy5jdXJyZW50U2xpZGUsIHRvdGFsQ291bnQsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIF90aGlzLiRob29wZXIuc2xpZGVUbyhpbmRleCk7XG4gICAgfSkgOiByZW5kZXJGcmFjdGlvbihoLCB0aGlzLmN1cnJlbnRTbGlkZSwgdG90YWxDb3VudCk7XG4gICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgICdob29wZXItcGFnaW5hdGlvbic6IHRydWUsXG4gICAgICAgICdpcy12ZXJ0aWNhbCc6IHRoaXMuJGhvb3Blci5jb25maWcudmVydGljYWxcbiAgICAgIH1cbiAgICB9LCBjaGlsZHJlbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGljb25OYW1lKGlzVmVydGljYWwsIGlzUlRMLCBpc1ByZXYpIHtcbiAgaWYgKGlzUHJldikge1xuICAgIHJldHVybiBpc1ZlcnRpY2FsID8gJ2Fycm93VXAnIDogaXNSVEwgPyAnYXJyb3dSaWdodCcgOiAnYXJyb3dMZWZ0JztcbiAgfVxuXG4gIHJldHVybiBpc1ZlcnRpY2FsID8gJ2Fycm93RG93bicgOiBpc1JUTCA/ICdhcnJvd0xlZnQnIDogJ2Fycm93UmlnaHQnO1xufVxuXG5mdW5jdGlvbiByZW5kZXJCdXR0b24oaCwgZGlzYWJsZWQsIHNsb3QsIGlzUHJldiwgX3JlZiwgb25DbGljaykge1xuICB2YXIgX2NsYXNzO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gX3JlZi5pc1ZlcnRpY2FsLFxuICAgICAgaXNSVEwgPSBfcmVmLmlzUlRMO1xuICB2YXIgY2hpbGRyZW4gPSBzbG90ICYmIHNsb3QubGVuZ3RoID8gc2xvdCA6IFtoKEljb24sIHtcbiAgICBwcm9wczoge1xuICAgICAgbmFtZTogaWNvbk5hbWUoaXNWZXJ0aWNhbCwgaXNSVEwsIGlzUHJldilcbiAgICB9XG4gIH0pXTtcbiAgcmV0dXJuIGgoJ2J1dHRvbicsIHtcbiAgICBjbGFzczogKF9jbGFzcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImhvb3Blci1cIi5jb25jYXQoaXNQcmV2ID8gJ3ByZXYnIDogJ25leHQnKSwgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsICdpcy1kaXNhYmxlZCcsIGRpc2FibGVkKSwgX2NsYXNzKSxcbiAgICBhdHRyczoge1xuICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBjbGljazogb25DbGlja1xuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufVxuXG52YXIgTmF2aWdhdGlvbiA9IHtcbiAgaW5qZWN0OiBbJyRob29wZXInXSxcbiAgbmFtZTogJ0hvb3Blck5hdmlnYXRpb24nLFxuICBjb21wdXRlZDoge1xuICAgIGlzUHJldkRpc2FibGVkOiBmdW5jdGlvbiBpc1ByZXZEaXNhYmxlZCgpIHtcbiAgICAgIGlmICh0aGlzLiRob29wZXIuY29uZmlnLmluZmluaXRlU2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuJGhvb3Blci5jdXJyZW50U2xpZGUgPT09IDA7XG4gICAgfSxcbiAgICBpc05leHREaXNhYmxlZDogZnVuY3Rpb24gaXNOZXh0RGlzYWJsZWQoKSB7XG4gICAgICBpZiAodGhpcy4kaG9vcGVyLmNvbmZpZy5pbmZpbml0ZVNjcm9sbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiRob29wZXIuY29uZmlnLnRyaW1XaGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRob29wZXIuY3VycmVudFNsaWRlID09PSB0aGlzLiRob29wZXIuc2xpZGVzQ291bnQgLSBNYXRoLm1pbih0aGlzLiRob29wZXIuY29uZmlnLml0ZW1zVG9TaG93LCB0aGlzLiRob29wZXIuc2xpZGVzQ291bnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kaG9vcGVyLmN1cnJlbnRTbGlkZSA9PT0gdGhpcy4kaG9vcGVyLnNsaWRlc0NvdW50IC0gMTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzbGlkZU5leHQ6IGZ1bmN0aW9uIHNsaWRlTmV4dCgpIHtcbiAgICAgIHRoaXMuJGhvb3Blci5zbGlkZU5leHQoKTtcbiAgICAgIHRoaXMuJGhvb3Blci5yZXN0YXJ0VGltZXIoKTtcbiAgICB9LFxuICAgIHNsaWRlUHJldjogZnVuY3Rpb24gc2xpZGVQcmV2KCkge1xuICAgICAgdGhpcy4kaG9vcGVyLnNsaWRlUHJldigpO1xuICAgICAgdGhpcy4kaG9vcGVyLnJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgaXNSVEw6IHRoaXMuJGhvb3Blci5jb25maWcucnRsLFxuICAgICAgaXNWZXJ0aWNhbDogdGhpcy4kaG9vcGVyLmNvbmZpZy52ZXJ0aWNhbFxuICAgIH07XG4gICAgdmFyIGNoaWxkcmVuID0gW3JlbmRlckJ1dHRvbihoLCB0aGlzLmlzUHJldkRpc2FibGVkLCB0aGlzLiRzbG90c1snaG9vcGVyLXByZXYnXSwgdHJ1ZSwgY29uZmlnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2xpZGVQcmV2KCk7XG4gICAgfSksIHJlbmRlckJ1dHRvbihoLCB0aGlzLmlzTmV4dERpc2FibGVkLCB0aGlzLiRzbG90c1snaG9vcGVyLW5leHQnXSwgZmFsc2UsIGNvbmZpZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNsaWRlTmV4dCgpO1xuICAgIH0pXTtcbiAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgY2xhc3M6IHtcbiAgICAgICAgJ2hvb3Blci1uYXZpZ2F0aW9uJzogdHJ1ZSxcbiAgICAgICAgJ2lzLXZlcnRpY2FsJzogdGhpcy4kaG9vcGVyLmNvbmZpZy52ZXJ0aWNhbCxcbiAgICAgICAgJ2lzLXJ0bCc6IHRoaXMuJGhvb3Blci5jb25maWcucnRsXG4gICAgICB9XG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYXJvdXNlbDtcbmV4cG9ydCB7IENhcm91c2VsIGFzIEhvb3BlciwgSWNvbiwgTmF2aWdhdGlvbiwgUGFnaW5hdGlvbiwgUHJvZ3Jlc3MsIFNsaWRlLCBNaXhpbiBhcyBhZGRvbk1peGluIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hooper/dist/hooper.esm.js\n");

/***/ })

}]);